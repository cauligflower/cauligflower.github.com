Windows内核学习之蓝屏问题修复-2
=====

**Author：[cauligflower](http://cauligflower.github.com)**

**Time：2013.08.03**

**Title：蓝屏问题修复-2**

-----

上次只是使用Windbg查看了，```!analyze -v```的结果，并没有对代码进行分析和修改，这次补充这一部分。

程序有两处导致崩溃，先贴部分代码。

```
VOID DriverUnload(IN PDRIVER_OBJECT  DriverObject)
{
	DbgPrint("Driver Unload Called\n");
}

BOOLEAN IsExitProcess(PEPROCESS Eprocess)
{
	WIN_VER_DETAIL WinVer;
	ULONG SectionObjectOffset = 0;
	ULONG SectionObject;
	ULONG SegmentOffset = 0;
	ULONG Segment;
	BOOLEAN bRetOK = FALSE;

	if (!WinVersion)
	{
		WinVer = GetWindowsVersion();
	}
	else
	{
		WinVer = WinVersion;
	}

	switch (WinVer)
	{
	case WINDOWS_VERSION_XP:
		SectionObjectOffset = 0x138;
		SegmentOffset = 0x14;        
		break;
	case WINDOWS_VERSION_2K3_SP1_SP2:
		SectionObjectOffset = 0x124;
		SegmentOffset = 0x14;
		break;
	case WINDOWS_VERSION_7_7600_UP:
		SectionObjectOffset = 0x128;
		SegmentOffset = 0x14;
		break;
	case WINDOWS_VERSION_7_7000:
		SectionObjectOffset = 0x128;
		SegmentOffset = 0x14;
		break;
	}

	SectionObject = *(PULONG)((ULONG)Eprocess + SectionObjectOffset);
	Segment = *(PULONG)((ULONG)SectionObject + SegmentOffset);
	if (MmIsAddressValid((PVOID)Segment))
	{
		bRetOK = TRUE;
	}
	return bRetOK;
}

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING theRegistryPath)
{
	

	WCHAR *pwz_buf = NULL;
	HANDLE Handle = NULL;
	NTSTATUS status;

	DriverObject->DriverUnload = DriverUnload;

	_asm int 3

	pwz_buf = (WCHAR *)ExAllocatePool(NonPagedPool, 30);
	if (pwz_buf)
	{
		memcpy(pwz_buf,theRegistryPath->Buffer, theRegistryPath->Length);
		ExFreePool(pwz_buf);
	}

	IsExitProcess(0x80008000);

	return STATUS_SUCCESS;
}
```

####第一处：```ExFreePool(pwz_buf);```

在代码中加入```_asm int 3```，单步执行代码，并查看相关变量。

![](http://y.photo.qq.com/img?s=HxKAbs784&l=y.jpg)

![](http://y.photo.qq.com/img?s=PjgMKqld0&l=y.jpg)

![](http://y.photo.qq.com/img?s=e5Y7oWBFU&l=y.jpg)

至此可以看到，pwz_buf申请了30字节的内存空间，但是theRegistryPath字串长度明显超过30字节。

根据theRegistryPath->Length长度进行memcpy，会破坏pwz_buf本身的堆内存空间，导致蓝屏。

这里pwz_buf需要根据theRegistryPath->Length长度申请内存。



####第二处：```SectionObject = *(PULONG)((ULONG)Eprocess + SectionObjectOffset);```

![](http://y.photo.qq.com/img?s=ACxB6AXIe&l=y.jpg)

此处虽然符号断掉，变量的Value显示不出来，不过根据之前的数值

Eprocess = 0x80008000 

SectionObjectOffset = 0x128

以ULONG的形式取0x80008128内存的数值，从Memoery处看到此处内存本身是无法读取的，所以这里已经存在问题，需要对数值进行Check，不然会读到错误的内存导致蓝屏。

其实这个问题是从参数处引入，```IsExitProcess(0x80008000);```这里的0x80008000就是一处错误，但是函数本身可以通过加入防御性编程的assert。

这里加入如下修改：

1.对传入参数Eprocess的值以及内存地址进行检查

```
if (!Eprocess || !MmIsAddressValid(Eprocess))
{
	return bRetOK;
}
```

2.对SectionObject和Segment的地址是否可读进行检查

```
SectionObject = *(PULONG)((ULONG)Eprocess + SectionObjectOffset);
if (MmIsAddressValid((PVOID)SectionObject))
{
	Segment = *(PULONG)((ULONG)SectionObject + SegmentOffset);
	if (MmIsAddressValid((PVOID)Segment))
	{
		bRetOK = TRUE;
	}
}
```

经过上两处修改，驱动已经可以成功运行。

PS：对于安装了VMTools后，重启后无法跟虚拟机系统互拖文件，可以使用VMWare的共享文件夹方式共享主机的文件夹，对虚拟机给与读写权限，即使不能拖动也能正常传输文件。

VM-->setting-->option-->ShareFolders，根据需要设置即可。

-----

参考书目

《软件调试》：http://book.douban.com/subject/3088353/
