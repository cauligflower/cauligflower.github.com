Windows内核学习之基本驱动框架-2
=====

**Author：[cauligflower](http://cauligflower.github.com)**

**Time：2013.08.04**

**Title：基本驱动框架-2-驱动最基本框架**

-----

A总用房子和电话的概念，讲解了程序的一些基础概念，这里都能够理解，就不记录了。

####一.包含头文件，这里使用了条件编译指令，使用C的形式包含ntifs.h。

因为这里使用了CPP文件，WDK会使用C++语法编译，链接时如果按照C++的编译符号定义则无法找到。

```C
#ifdef __cplusplus
extern "C"
{
#endif
#include <ntifs.h>
#ifdef __cplusplus
}
#endif
```

####二.驱动入口函数

类似应用层，控制台程序入口函数为main，Win32入口函数WinMain，DLL入口函数DllMain是一样的。驱动程序由内核的I/O管理器调用。

```
extern "C"
NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObj, IN PUNICODE_STRING pRegistryPath)
{
  return STATUS_SUCCESS;
}
```

DriverEntry包含两个参数，驱动对象和注册表字符串。

#####1.驱动对象DRIVER_OBJECT

每个驱动程序会有唯一的驱动对象与之对应，驱动对象是驱动程序在加载时，由内核的对象管理器创建。

通过Windbg查看驱动对象的结构定义如下：（可能相同对象结构，在不同系统版本上，内容会有差异，此处以Windbg在Win7 7061来记录）

```
kd> dt _DRIVER_OBJECT
ntdll!_DRIVER_OBJECT
   +0x000 Type             : Int2B
   +0x002 Size             : Int2B
   +0x004 DeviceObject     : Ptr32 _DEVICE_OBJECT //设备对象
   +0x008 Flags            : Uint4B
   +0x00c DriverStart      : Ptr32 Void          //驱动在内存中的开始地址
   +0x010 DriverSize       : Uint4B              //驱动大小
   +0x014 DriverSection    : Ptr32 Void
   +0x018 DriverExtension  : Ptr32 _DRIVER_EXTENSION
   +0x01c DriverName       : _UNICODE_STRING      //驱动名称
   +0x024 HardwareDatabase : Ptr32 _UNICODE_STRING
   +0x028 FastIoDispatch   : Ptr32 _FAST_IO_DISPATCH
   +0x02c DriverInit       : Ptr32     long 
   +0x030 DriverStartIo    : Ptr32     void 
   +0x034 DriverUnload     : Ptr32     void      //驱动卸载例程
   +0x038 MajorFunction    : [28] Ptr32     long //IRP派遣函数例程
```

从截图中可以看到，驱动对象建立后，具体的内容。

![](http://y.photo.qq.com/img?s=FoR9yz8dP&l=y.jpg)

其中DriverStart为驱动在内存中的开始地址，驱动也是PE文件，查看该地址的内存，可以看到非常熟悉的PE头。

![](http://y.photo.qq.com/img?s=g6ZRuOh1a&l=y.jpg)

#####2.UNICODE_STRING

```
kd> dt _UNICODE_STRING
ntdll!_UNICODE_STRING
   +0x000 Length           : Uint2B        //字符串长度
   +0x002 MaximumLength    : Uint2B        //最大长度
   +0x004 Buffer           : Ptr32 Uint2B  //Buffer
```

####三.驱动卸载函数和IRP派遣函数

这里没有涉及到具体的逻辑，A总只是用应用层的一个概念来讲了下，所以这里暂时先了解到。

驱动程序向Windows的I/O管理器注册了一系列的回调函数，操作系统在适当的时候进行调用，例如驱动呗卸载，就会去调用所定义的DriverUnload。至于IRP派遣函数，以后明白了，再补充吧。

```
pDriverObj->DriverUnload = DriverUnload;
pDriverObj->MajorFunction[IRP_MJ_CREATE] = HelloDispatchRoutine;
pDriverObj->MajorFunction[IRP_MJ_READ] = HelloDispatchRoutine;
pDriverObj->MajorFunction[IRP_MJ_CLOSE] = HelloDispatchRoutine;
pDriverObj->MajorFunction[IRP_MJ_WRITE] = HelloDispatchRoutine;
```

都没有具体的内容，但是确实是驱动程序的一部分。

```
VOID DriverUnload(IN PDRIVER_OBJECT pDriverObj)
{

}

NTSTATUS HelloDispatchRoutine(IN PDEVICE_OBJECT pDevicObj, IN PIRP pIrp)
{
	NTSTATUS status = STATUS_SUCCESS;
	pIrp->IoStatus.Status = status;

	IoCompleteRequest(pIrp,IO_NO_INCREMENT);

	return status;
}
```

执行后通过DebugView看到KdPrint所打印的内容。

![](http://y.photo.qq.com/img?s=QpbUb2JWJ&l=y.jpg)

PS：把涉及到设备，设备链接，以及与通信部分的代码删除了，后面再继续学习。
