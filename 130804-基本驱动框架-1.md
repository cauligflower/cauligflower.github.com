Windows内核学习之基本驱动框架-1
=====

**Author：[cauligflower](http://cauligflower.github.com)**

**Time：2013.08.04**

**Title：基本驱动框架-1-驱动编写编译环境搭建**

-----

Windows驱动程序分为两类，一类是不支持即插即用的NT式驱动程序，一类是支持即插即用的WDM驱动程序。

NT式驱动需要导入NTDDK.h头文件，而WDM式驱动则需要导入WDM.h头文件。但是在学习过程中，看A总代码，发现他引入的是```Ntifs.h```，查了一下MSDN，又跟A总请教后，主要是Ntifs.h包含的内容是最全面的。

> 在 Windows Vista 版本的 WDK 之前，用于驱动程序开发的主要头文件为 Wdm.h、Ntddk.h 和
> Ntifs.h，它们包含很多重复声明。
> 
> 从 Windows Vista 版本的 WDK 开始，Wdm.h、Ntddk.h 和 Ntifs.h
> 将按层次结构来组织并且不包含重复信息。上层的文件将包含下层的文件。每个函数和结构声明仅出现一次。 Ntifs.h 包含 Ntddk.h，而
> Ntddk.h 又包含 Wdm.h。

![](http://y.photo.qq.com/img?s=zfKVnHrx9&l=y.jpg)

下面是一个最基本的驱动框架，能够加载启动以及卸载。

####一.源文件（C文件/CPP文件，及头文件）

```C
#pragma once

#ifdef __cplusplus
extern "C"
{
#endif
#include <ntifs.h>
#ifdef __cplusplus
}
#endif

VOID DriverUnload(IN PDRIVER_OBJECT pDriverObj)
{
  KdPrint(("Enter DriverUnload\n"));
	
	KdPrint(("End DriverUnload\n"));
}

NTSTATUS HelloDispatchRoutine(IN PDEVICE_OBJECT pDevicObj, IN PIRP pIrp)
{
	KdPrint(("Enter HelloDispatchRoutine\n"));

	NTSTATUS status = STATUS_SUCCESS;
	pIrp->IoStatus.Status = status;

	IoCompleteRequest(pIrp,IO_NO_INCREMENT);

	KdPrint(("End HelloDispatchRoutine\n"));
	return status;
}

extern "C"
NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObj, IN PUNICODE_STRING pRegistryPath)
{
	KdPrint(("Enter DriverEntry\n"));

	pDriverObj->DriverUnload = DriverUnload;
	pDriverObj->MajorFunction[IRP_MJ_CREATE] = HelloDispatchRoutine;
	pDriverObj->MajorFunction[IRP_MJ_READ] = HelloDispatchRoutine;
	pDriverObj->MajorFunction[IRP_MJ_CLOSE] = HelloDispatchRoutine;
	pDriverObj->MajorFunction[IRP_MJ_WRITE] = HelloDispatchRoutine;
	
	KdPrint(("End DriverEntry\n"));
	return STATUS_SUCCESS;
}
```

####二.sources和markfile文件

sources主要用来描述驱动工程的基本信息（使用时，需要将//注释符以及之后的中文删除）。

```
//驱动名称
TARGETNAME = HelloDriver
//编译目标类型，这里填写DRIVER表示编译为sys驱动程序
TARGETTYPE = DRIVER
//编译输出目录
TARGETPATH = obj

//指定源文件
SOURCES = HelloDriver.cpp\
```

而makefile主要来指定NMAKE的依赖关系。一般内容如下，且不用修改。

```
!INCLUDE $(NTMAKEENV)\makefile.def
```

根据MSDN描述，makefile含义如下：

> The NMAKE utility uses Makefile files to generate dependency and
> command lists.
> 
> Starting with the Windows Driver Kit (WDK) for Windows Vista, it is no
> longer required for the Makefile file to be in every project. By
> default, the Build utility includes the Makefile.def if the Makefile
> file is not found in the project. Any custom tasks that are required
> in a project should be moved to Makefile.inc as appropriate.

而且从DDK更新到WDK后，可以不添加该文件，直接build，这一点也尝试了，确实不需要makefile可以编译驱动。

####三.命令行编译驱动程序

驱动也可以通过建立IDE（VC6，VS系列）工程模版，设置编译和链接参数，使用IDE编译链接。这里主要为了自己方便，根据A总的推荐，使用VS2010编码，使用WDK命令行方式进行编译。

#####1.VS2010设置

1.设置VAX中头文件路径，使之可以使用GO功能，更方便的查看结构和函数定义。

![](http://y.photo.qq.com/img?s=6DsYfFXHG&l=y.jpg)

设置位置如下（可以根据自身需要添加更多头文件路径）：

![](http://y.photo.qq.com/img?s=17teeoQkn&l=y.jpg)

#####2.设置VS2010工程属性，使VS能够识别到头文件的定义。

但是VS2010相较VS2008，把目录包含位置调整了，通过“选项”工具栏无法设置。

![](http://y.photo.qq.com/img?s=0x3khsVTJ&l=y.jpg)

此时需要打开属性管理器，选择Microsoft.Cpp.Win32.user，双击，修改此文件，并保存工程，以后建立的驱动工程，都会识别到头文件。

![](http://y.photo.qq.com/img?s=mnzBKQsAD&l=y.jpg)

![](http://y.photo.qq.com/img?s=kpvrJ85ZS&l=y.jpg)

之后就在VS中，写好代码，通过WDK进行编译即可。

这里的X86，指传统32位系统；X64，指传统64位系统；IA64主要针对Intel安腾CPU，接触的不是很多。

而Check版本对应应用层的Debug版本；Free版本对应应用层的Release版本。

![](http://y.photo.qq.com/img?s=bnocW1bqB&l=y.jpg)
