Windows内核学习之蓝屏问题修复-1
=====

**Author：[cauligflower](http://cauligflower.github.com)**

**Time：2013.08.03**

**Title：蓝屏问题修复-1**

-----

###一.有符号，双机调试

首先建立双机的连接，加载相关驱动的PDB文件，按g让虚拟机运行起来，虚拟机系统加载并启动驱动程序，Windbg会捕获崩溃。

Fatal System Error: 0x00000019 (0x00000020,0x882D1740,0x882D1768,0x08050006)

通过MSDN的Bug Checks(Blue Screens)查询，http://msdn.microsoft.com/en-us/library/windows/hardware/hh450912(v=vs.85).aspx

0x19：BAD_POOL_HEADER，内存池破坏。

Parameter 1：The pool block header size is corrupt，内存块大小错误。

![](http://y.photo.qq.com/img?s=uhDtgJnN2&l=y.jpg)

使用```!analyze -v```自动分析Dump，结果如下：

![](http://y.photo.qq.com/img?s=ZriVsBlrM&l=y.jpg)

```
kd> !analyze -v
*******************************************************************************
*                                                                             *
*                        Bugcheck Analysis                                    *
*                                                                             *
*******************************************************************************

BAD_POOL_HEADER (19)
The pool is already corrupt at the time of the current request.
This may or may not be due to the caller.
The internal pool links must be walked to figure out a possible cause of
the problem, and then special pool applied to the suspect tags or the driver
verifier to a suspect driver.
Arguments:
Arg1: 00000020, a pool block header size is corrupt.
Arg2: 882d1740, The pool entry we were looking for within the page.
Arg3: 882d1768, The next pool entry.
Arg4: 08050006, (reserved)

Debugging Details:
------------------


BUGCHECK_STR:  0x19_20

POOL_ADDRESS:  882d1740 Nonpaged pool

DEFAULT_BUCKET_ID:  VISTA_DRIVER_FAULT

PROCESS_NAME:  System

CURRENT_IRQL:  2

LAST_CONTROL_TRANSFER:  from 83f27fff to 83ec40c0

STACK_TEXT:  
807e952c 83f27fff 00000003 72717bff 00000065 nt!RtlpBreakWithStatusInstruction
807e957c 83f28afd 00000003 882d1740 000001ff nt!KiBugCheckDebugBreak+0x1c
807e9940 83f69c6b 00000019 00000020 882d1740 nt!KeBugCheck2+0x68b
807e99bc 9559d179 882d1748 00000000 8400c360 nt!ExFreePoolWithTag+0x1b1
807e99d8 8400c36a 865797b8 86639000 00000000 BSODCheck!DriverEntry+0x59 [c:\users\cauliaflower\desktop\bsodcheck\bsodcheck.c @ 61]
807e9bbc 8400fe1c 00000001 00000000 807e9be4 nt!IopLoadDriver+0x7ed
807e9c00 83ec6a6b 8bee3bd0 00000000 863e6d48 nt!IopLoadUnloadDriver+0x70
807e9c50 84052056 00000001 72717213 00000000 nt!ExpWorkerThread+0x10d
807e9c90 83efa1a9 83ec695e 00000001 00000000 nt!PspSystemThreadStartup+0x9e
00000000 00000000 00000000 00000000 00000000 nt!KiThreadStartup+0x19


STACK_COMMAND:  kb

FOLLOWUP_IP: 
BSODCheck!DriverEntry+59 [c:\users\cauliaflower\desktop\bsodcheck\bsodcheck.c @ 61]
9559d179 6800800080      push    80008000h

FAULTING_SOURCE_CODE:  
    57: 	{
    58: 		memcpy(pwz_buf,theRegistryPath->Buffer,theRegistryPath->Length);
    59: 		ExFreePool(pwz_buf);
    60: 	}
>   61: 	IsExitProcess(0x80008000);
    62: 
    63: 	return STATUS_SUCCESS;
    64: }


SYMBOL_STACK_INDEX:  4

SYMBOL_NAME:  BSODCheck!DriverEntry+59

FOLLOWUP_NAME:  MachineOwner

MODULE_NAME: BSODCheck

IMAGE_NAME:  BSODCheck.sys

DEBUG_FLR_IMAGE_TIMESTAMP:  51fbba0f

FAILURE_BUCKET_ID:  0x19_20_BSODCheck!DriverEntry+59

BUCKET_ID:  0x19_20_BSODCheck!DriverEntry+59

Followup: MachineOwner
```

从analyze信息直接可以看到出问题所在的，这里不再详述。




###二.有符号，Dump调试

修复上面的蓝屏问题，但是不进行双机调试，在虚拟机内进行设置，写入Dump信息处保存为核心内存转储。

![](http://y.photo.qq.com/img?s=MC9U6kZOI&l=y.jpg)

在虚拟机内直接加载运行驱动程序，会发现系统直接蓝屏。

![](http://y.photo.qq.com/img?s=ClRLxJych&l=y.jpg)

有简单的提示信息，包括出错模块BSODCheck.sys，以及出错的代码。

根据MSDN的信息，“The PAGE_FAULT_IN_NONPAGED_AREA bug check has a value of 0x00000050. This indicates that invalid system memory has been referenced.”

对无效的内存地址进行了read操作导致蓝屏，但是具体的代码位置还不清楚，需要提取Dump分析。

重启虚拟机后，在```%systemroot%\minidump```中找到Dump提取出来，通过Windbg进行分析。

依然使用```!analyze -v```命令，可以看到如下分析结果。

```
kd> !analyze -v
*******************************************************************************
*                                                                             *
*                        Bugcheck Analysis                                    *
*                                                                             *
*******************************************************************************

PAGE_FAULT_IN_NONPAGED_AREA (50)
Invalid system memory was referenced.  This cannot be protected by try-except,
it must be protected by a Probe.  Typically the address is just plain bad or it
is pointing at freed memory.
Arguments:
Arg1: 80008128, memory referenced.
Arg2: 00000000, value 0 = read operation, 1 = write operation.
Arg3: 970ac0c8, If non-zero, the instruction address which referenced the bad memory
	address.
Arg4: 00000000, (reserved)

Debugging Details:
------------------

FAULTING_MODULE: 83e46000 nt

DEBUG_FLR_IMAGE_TIMESTAMP:  51fbed27

READ_ADDRESS: unable to get nt!MmSpecialPoolStart
unable to get nt!MmSpecialPoolEnd
unable to get nt!MmPoolCodeStart
unable to get nt!MmPoolCodeEnd
 80008128 

FAULTING_IP: 
BSODCheck!IsExitProcess+98 [c:\users\cauliaflower\desktop\bsodcheck\bsodcheck.c @ 40]
970ac0c8 8b11            mov     edx,dword ptr [ecx]

MM_INTERNAL_CODE:  0

CUSTOMER_CRASH_COUNT:  1

DEFAULT_BUCKET_ID:  VISTA_DRIVER_FAULT

BUGCHECK_STR:  0x50

CURRENT_IRQL:  0

LAST_CONTROL_TRANSFER:  from 83e87468 to 83ed43bf

STACK_TEXT:  
WARNING: Stack unwind information not available. Following frames may be wrong.
807e9918 83e87468 00000000 80008128 00000000 nt+0x8e3bf
807e99c0 970ac18b 80008000 84009360 873e0948 nt+0x41468
807e99d0 00000000 807e9bbc 8400936a 886229a0 BSODCheck!DriverEntry+0x6b [c:\users\cauliaflower\desktop\bsodcheck\bsodcheck.c @ 63]


STACK_COMMAND:  .bugcheck ; kb

FOLLOWUP_IP: 
BSODCheck!IsExitProcess+98 [c:\users\cauliaflower\desktop\bsodcheck\bsodcheck.c @ 40]
970ac0c8 8b11            mov     edx,dword ptr [ecx]

FAULTING_SOURCE_CODE:  
    36: 		SectionObjectOffset = 0x128;
    37: 		SegmentOffset=0x14;
    38: 		break;
    39: 	}
>   40: 	SectionObject = *(PULONG)((ULONG)Eprocess + SectionObjectOffset);
    41: 	Segment = *(PULONG)((ULONG)SectionObject + SegmentOffset);
    42: 	if (MmIsAddressValid((PVOID)Segment)){
    43: 		bRetOK = TRUE;
    44: 	}
    45: 	return bRetOK;


SYMBOL_NAME:  BSODCheck!IsExitProcess+98

FOLLOWUP_NAME:  MachineOwner

MODULE_NAME: BSODCheck

IMAGE_NAME:  BSODCheck.sys

BUCKET_ID:  WRONG_SYMBOLS

Followup: MachineOwner
```

通过分析结果，可以直接看到问题所在。




###三.无符号，Duump调试

还是用刚才的Dump，但是删掉之前的PDB符号文件，在Windbg下先使用```!analyze -v```命令，得到基础的分析结果。

```
kd> !analyze -v
*******************************************************************************
*                                                                             *
*                        Bugcheck Analysis                                    *
*                                                                             *
*******************************************************************************

PAGE_FAULT_IN_NONPAGED_AREA (50)
Invalid system memory was referenced.  This cannot be protected by try-except,
it must be protected by a Probe.  Typically the address is just plain bad or it
is pointing at freed memory.
Arguments:
Arg1: 80008128, memory referenced.
Arg2: 00000000, value 0 = read operation, 1 = write operation.
Arg3: 970ac0c8, If non-zero, the instruction address which referenced the bad memory
	address.
Arg4: 00000000, (reserved)

Debugging Details:
------------------

Unable to load image \??\C:\Users\cauligflower\Desktop\BSODCheck.sys, Win32 error 0n2
*** WARNING: Unable to verify timestamp for BSODCheck.sys
*** ERROR: Module load completed but symbols could not be loaded for BSODCheck.sys

Could not read faulting driver name

READ_ADDRESS: GetPointerFromAddress: unable to read from 83faf848
Unable to read MiSystemVaType memory at 83f8ee20
 80008128 

FAULTING_IP: 
BSODCheck+10c8
970ac0c8 8b11            mov     edx,dword ptr [ecx]

MM_INTERNAL_CODE:  0

CUSTOMER_CRASH_COUNT:  1

DEFAULT_BUCKET_ID:  VISTA_DRIVER_FAULT

BUGCHECK_STR:  0x50

PROCESS_NAME:  System

CURRENT_IRQL:  0

TRAP_FRAME:  807e9930 -- (.trap 0xffffffff807e9930)
ErrCode = 00000000
eax=00000004 ebx=00000000 ecx=80008128 edx=00000004 esi=886229a0 edi=86958000
eip=970ac0c8 esp=807e99a4 ebp=807e99c0 iopl=0         nv up ei ng nz na pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010286
BSODCheck+0x10c8:
970ac0c8 8b11            mov     edx,dword ptr [ecx]  ds:0023:80008128=????????
Resetting default scope

LAST_CONTROL_TRANSFER:  from 83e87468 to 83ed43bf

STACK_TEXT:  
807e9918 83e87468 00000000 80008128 00000000 nt!MmAccessFault+0x106
807e9918 970ac0c8 00000000 80008128 00000000 nt!KiTrap0E+0xdc
WARNING: Stack unwind information not available. Following frames may be wrong.
807e99c0 970ac18b 80008000 84009360 873e0948 BSODCheck+0x10c8
807e99d8 8400936a 886229a0 86958000 00000000 BSODCheck+0x118b
807e9bbc 8400ce1c 00000001 00000000 807e9be4 nt!IopLoadDriver+0x7ed
807e9c00 83ec3a6b 96d87bd0 00000000 865fdd48 nt!IopLoadUnloadDriver+0x70
807e9c50 8404f056 00000001 a02cf598 00000000 nt!ExpWorkerThread+0x10d
807e9c90 83ef71a9 83ec395e 00000001 00000000 nt!PspSystemThreadStartup+0x9e
00000000 00000000 00000000 00000000 00000000 nt!KiThreadStartup+0x19


STACK_COMMAND:  kb

FOLLOWUP_IP: 
BSODCheck+10c8
970ac0c8 8b11            mov     edx,dword ptr [ecx]

SYMBOL_STACK_INDEX:  2

SYMBOL_NAME:  BSODCheck+10c8

FOLLOWUP_NAME:  MachineOwner

MODULE_NAME: BSODCheck

IMAGE_NAME:  BSODCheck.sys

DEBUG_FLR_IMAGE_TIMESTAMP:  51fbed27

FAILURE_BUCKET_ID:  0x50_BSODCheck+10c8

BUCKET_ID:  0x50_BSODCheck+10c8

Followup: MachineOwner
```

可以看到FAULTING_IP处的

相对地址：BSODCheck+10c8

绝对地址：970ac0c8

机器码：8b11

反汇编：mov edx,dword ptr [ecx]

通过u命令查看0x970ac0c8附近的反汇编指令。

![](http://y.photo.qq.com/img?s=2nF9Ig3Cn&l=y.jpg)

可以提取0x970ac0c8附近附近的特征机器码（含绝对地址的，尽量避免），例如这里提取：8b 11 89 55 f8 8b 45 f8。

在IDA中查询机器码串（ALT+B），可以找反汇编代码位置。

![](http://y.photo.qq.com/img?s=V9LDT3p7p&l=y.jpg)

IDA相较Windbg有更强大的逆向分析能力，例如使用F5，进行反编译，查看相关代码。

![](http://y.photo.qq.com/img?s=yq8DztD8o&l=y.jpg)

也能够很方便的定位问题。

-----

参考书目

《Windows高级调试》：http://book.douban.com/subject/3781532/